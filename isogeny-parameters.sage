from sage.schemes.elliptic_curves.cm import hilbert_class_polynomial


def SRAparam(B,verbose=False):
    """
    Calculates a suitable N, p along with the auxillary curve and isogeny path.
    N and p are found to be of about B bits.
    """
    N,p = findNP(B)
    Eaux = complexMultiplicationCurve(N,p)
    isogenyList = GetIsogenyPath(Eaux,N)
    if verbose:
        print ""
        print "SRAparam(" + str(B) + ") running:" 
        print "N=", N
        print "p=", p
        print "Eaux is: ", Eaux
        print "isogenyList is: ", isogenyList

        print "SRAparam Done!"
    return N,p,Eaux,isogenyList

# Factors out all primes <= B from N. Returns factor list and non-smooth part.
def TrialDivision(N,B, factored=True):
    N_old = N
    BFactors = [p for p in primes(0,B+1)]

    factorList = []
    j = 0
    for i in xrange(len(BFactors)):
        b = BFactors[i]
        if N % b == 0 and N != 1:
            factorList.append([b, 1])
            N = N // b
        while N % b == 0 and N != 1:
            factorList[-1][1] += 1
            N = N // b

    if factored == True:
        return factorList, N
    else:
        return N_old // N, N

        
# Creates an Elliptic Curve of order N, defined over finite field Fp
# Taken from magma code based upon Broker's thesis, p.30.
def complexMultiplicationCurve(N,p):
    delta = (p+1 - N)**2 - 4*p

    #print delta
    if delta % 4 == 0:
        delta = delta.squarefree_part()
        delta *= 4
    else:
        delta = delta.squarefree_part()

    #print delta
    # Hilbert Polynomial
    PH = hilbert_class_polynomial(delta)
    Fp = GF(p)
    Rp.<X> = PolynomialRing(Fp)
    PH = Rp(PH)

    # j invariant
    allJ = PH.roots()
    j = allJ[0][0]

    # curve
    if Fp(j) == Fp(0):
        E = EllipticCurve(Fp,[0,0,0,0,1])
    elif Fp(j) == Fp(1728):
        E = EllipticCurve(Fp,[0,0,0,1,0])
    else:
        a = 27*j/(4*(1728-j))
        E = EllipticCurve(Fp,[0,0,0,a,-a])

    QuadraticTwists = [E, E.quadratic_twist()]
    OrderQuadraticTwists = [E.order() for E in QuadraticTwists]
    E = QuadraticTwists[OrderQuadraticTwists.index(N)]

    # Sanity check
    if E.order() != N:
        print "Algorithm failed"
        return False
    else:
        return E

# Find a curve with a smooth enough order of Fp by random trials
# precisely, at least with a N^alpha part of it must be B-Smooth
def FindSmoothCurve(p,alpha,B, feedback=False):
    Fp = GF(p)
    smooth = False
    SmoothPartBound = p**alpha

    count = 0
    while not smooth:
        count += 1
        # Generate a random curve
        a = Fp.random_element()
        b = Fp.random_element()
        delta = 4*a**3 + 27*b^2

        if delta != 0:
            E = EllipticCurve(Fp,[0,0,0,a,b])

            # Computer order of E
            N = E.order()
        
            # Check smoothness
            N1,N2 = TrialDivision(N,B, False)
            if feedback == True:
                print "Smooth part = ", N1
                print "Non-smooth part = ", N2
            smooth = (N1 >= SmoothPartBound)

    if feedback == True:
        print "Found a smooth enough curve after ", count, " trials."
        print "Smooth part of order is ", N1, " out of ", N
        print "Smooth part: ", N1, "Non-smooth part: ", N2

    return E

# Given a curve E and a smooth integer Np dividing its order, we return a sequence of isogenies with kernel equal to the subgroup of order N on E
def GetIsogenyPath(E, Np,verbose=False):
    # Parameters
    Fp = E.base_ring()
    p = Fp.characteristic()
    R.<u> = PolynomialRing(Fp)

    # Generators of the Elliptic Curve
    gens = E.gens()
    P1 = gens[0]
    P2 = E(0)
    if len(gens) > 1:
        P2 = gens[1]
        if verbose:
            print "Generators of the Elliptic Curve are ", P1, " and ", P2

    # Multiply these generators by cofactors to have Order(P1)*Order(P2)=Np
    Np1 = gcd(Np, P1.order())
    Np2 = Np//Np1
    P1 = (P1.order()//Np1)*P1
    P2 = (P2.order()//Np2)*P2
    if verbose:
        print "We work with the subgroup generated by ", P1, "and", P2
        print 'Order of P1 is', P1.order().factor(), "."
        print 'Order of P2 is', P2.order().factor(), "."
    
    # Isogeny sequence and curve sequence
    isogenyList = []
    curveList = [E]
    number_of_isogenies = 0
    gens = [P1,P2]

    # Adding one isogeny to the lists, whose kernel is generated by P
    def addIsogeny(isogenyList, curveList, gens,P):
        # Get the last Elliptic Curve in the list
        lastE = curveList[-1]

        # Find the minimal polynomial of the subgroup generated by P
        L = P.order()
        pol = prod([u - (j*P)[0] for j in xrange(1,L)])
        #print "pol", pol, P[0]

        # Compute the next isogeny and curve
        isogeny = lastE.isogeny(P)
        isogenyList.append(isogeny)
        curveList.append(isogeny.codomain())
        # Update generators 
        gens = [isogeny(gens[0]), isogeny(gens[1])]

        return isogenyList, curveList, gens

    # Sequence of prime factors with multiplicties
    factors = extractFactors(Np)
    if verbose:
        print "Factors of ", Np, "are: ", factors

    # Recursively add isogenies
    for i in xrange(0,2):
        P = gens[i]
        while P.order() != 1:
            ell = P.order().factor()[0][0]
            isogenyList, curveList, gens = addIsogeny(isogenyList, curveList, gens, (P.order()//ell)*P)
            number_of_isogenies +=1
            P = gens[i]

    return isogenyList

    



# Find parameters for SRA isogeny

# Wish to return smooth numbers with factors as small as possible
# N = prod_i (p_i)^(e_i)
# Ordering: N1 < N2 iff e1_i < e2_i

def nextSmooth(B, exponents):
    if exponents == []:
        return [ceil(B)], 2^ceil(B)

    # Take log of prime numbers
    primes = primes_first_n(len(exponents))
    log_primes = [log(p,2).n() for p in primes]

    # Find index to increase
    # We set indices to 0 and stop before N > 2B
    new_exponents = []
    index = 0
    found_index = False
    while (not found_index) and (index < len(exponents)-1):
        index += 1
        new_exponents = [0 for _ in  xrange(index)] + [exponents[index]+1] + [e for e in exponents[index+1:]]
        temp = sum([new_exponents[i]*log_primes[i] for i in xrange(0,len(exponents))])
        found_index = (temp < B+1)

    # If required, add a new prime to the list
    if not found_index:
        new_exponents = [0 for _ in exponents] + [1]
        primes = primes + [next_prime(primes[-1])]
        log_primes = log_primes + [log(primes[-1],2).n()]

    # Complete the new vector with powers of 2
    temp = sum(new_exponents[i]*log_primes[i] for i in xrange(0,len(primes)))
    new_exponents[0] = floor(B+1 - temp)
    return new_exponents, prod([primes[i]^new_exponents[i] for i in xrange(0,len(primes))])



# Find N, p with about B bits
# We try to calculate the discriminant up to DBOUND
# Attempting to solve (N+1 - 2)**2 + D*f^2 = 4N with N smooth, D small and p prime.
def findNP(B, DBOUND=100, verbose=False):
    from sympy.solvers.diophantine import diop_solve
    from sympy import sympify
    var('x,y')
    
    found_param = False
    exponents = []
    N = 0
    p = 0

    # We try successive values of N
    while not found_param:
        exponents, N = nextSmooth(B, exponents)
        D = 0
        if verbose:
            print "Searching for a good p for N=", N

        # We try successive values of D
        while (D < DBOUND) and (not found_param):
            D +=1
            while (not D.is_squarefree()):
                D +=1

            if verbose:
                print "Trying D=", D

            # We solve the equation x**2 + D*y**2 = 4N
            # Use sympy for now. Maybe change later.
            # We generate and filter the list for efficiency. Note that we are only interested in the x-solutions.
            # Special case of x = 0, which is not covered by sympy.
            xy_solutions = []
            zero_sols = 0
            temp = solve(D*y**2 - 4*N, y, solution_dict= True)
            if len(temp) != 0 and temp[0][y] in ZZ:
                zero_sols = 1
                p = ZZ(N+1)
                if p.is_prime() and (p-1) % 3 != 0:
                    found_param = True
                    return N, p

            temp = list(diop_solve(sympify(x**2 + D*y**2 - 4*N)))
            

            for xy in temp:
                if not abs(xy[0]) in xy_solutions:
                    xy_solutions.append(abs(xy[0]))
            if verbose:
                print "x^2 + %d*y^2 - 4*%d" %(D,N)
                print "Number of solutions to quadratic equation: ", len(xy_solutions) + zero_sols
                
            for z in xy_solutions:
                # We test p = N + 1 - x
                p = ZZ(N + 1 - z)
                if p.is_prime() and (p-1) % 3 != 0:
                    found_param = True
                    return N, p
                p = ZZ(N + 1 + z)
                if p.is_prime() and (p-1) % 3 != 0:
                    found_param = True
                    return N, p
    return N, p

def extractRoots(poly):
    try:
        return map(lambda a: a[0],poly.univariate_polynomial().roots())
    except Exception:
        return map(lambda a: a[0],poly.roots())


    
# Return all factors in a list
def extractFactors(n, unique=False):
    ans = []
    if unique == False:
        for i in factor(n):
            ans += [i[0]]*i[1]
        return ans
    else:
        for i in factor(n):
            ans+= [i[0]]
        return ans
    
def smartFactor(n,B=None, unique=False):
    if B == None:
        return extractFactors(n,unique)
    else:
        pass
    B = prime_range(B+1)
    factors = []
    for b in B:
        while n % b == 0:
            factors.append(b)
            n = n // b
        if n == 1:
            if unique == True:
                return unique_list(factors)
            else:
                return factors
    return False
